# 进程和线程的区别

## 概念

- 进程是CPU资源分配的最小单元
- 线程是CPU调度的最小单元

进程好比工厂，有单独额专属于自己的工厂资源
线程好比工人，多个工人在一个工厂中协作工作，工厂与工人是1:n的关系。也就是说，一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可以用这些共享内存。
多个工厂之间独立存在

*多进程与多线程*

- 多进程: 在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，多进程带来的好处是明显的，比如你可以听歌的同时，进行其他操作，两个进程之间不会相互影响
- 多线程: 程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是允许单个程序创建多个并行执行的线程来完成各自的任务。
以chrome浏览器为例，当你打开一个tab 页面时，就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程，js引擎线程，http请求线程等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

## 浏览器内核

简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。
浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：  

1. GUI渲染线程
   - 主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。
   - 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
   - 该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。
2. JS引擎线程
   - 该线程当然是主要负责处理 JavaScript脚本，执行代码
   - 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。
   - 当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。
3. 定时器触发线程
   - 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
   - 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。
4. 事件触发线程
   - 主要负责将准备好的事件交给 JS引擎线程执行。
比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。
5. 异步http请求线程
   - 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。
   - 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。

## 浏览器中的EventLoop  

## 1. Micro-Task 与 Macro-Task

浏览器端事件循环中的异步队列有两种: macro(宏任务)队列和micro(微任务)队列。**宏任务队列可以有多个，微任务队列只有一个**。

- 常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。
- 常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。

## 2.EventLoop过程解析

- 一开始执行栈空，我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro队列空，macro队列理由且只有一个script脚本(整体代码)
- 全局上下文(script标签)被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务。通过对一个接口的调用，可以产生新的macro-task和micro-task，它们会分别被推入各自的任务队列中。同步代码执行完了，script脚本会被移出macro队列，这个过程本质上是队列的macro-task的执行和出队的过程。
- 上一步我们出队的是一个macro-task，这一步我们处理的是micro-task。但需要注意的是，当macro-task出队时，任务是一个一个执行的；而micro-task出队时，任务是一队一队执行的。因此，我们处理micro队列这一步，会阻隔执行队列中的任务并把它出队，直到队列被清空。
- 执行渲染操作，更新界面
- 检查是否存在web Worker任务，如果有，则对其进行处理
- 上述过程循环往复，直到两个队列都清空

**当某个宏任务执行完毕后，js引擎会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈清空，再次读取微任务队列里的任务，依次类推**。

```javascript
Promise.resolve().then(()=>{
    console.log('promise1')
    setTimeout(()=>{
        console.log('setTimeout2')
    },0)
})

setTimeout(()=>{
    console.log('setTimeout1')
    Promise.resolve().then(()=>{
        console.log('promise2')
    })
})

// 结果: promise1 , setTimeout1 , promise2, setTimeout2
```

## 3 W3C最新标准下，宏任务和微任务无法继续满足浏览器复杂的事件处理逻辑。所以提出的新的标准:

   1. 针对不同的任务类型（taskType），可以产生多个队列去存放对应的task，浏览器内部依据情况进行调度
   2. 相同的任务类型必须放在同一个队列，在一个队列内，可以存放多个不同类型的任务
   3. 始终存在一个微任务队列，该任务队列的优先级在单次循环内，优先级始终最高。

目前chrome实现中，至少包含了以下队列：
   1.  延时队列： 用来存放计时器到达后的回调任务，优先级【中】
   2.  交互队列： 用来存放用户操作后产生的事件处理任务，优先级【高】
   3.  微队列：用户存放最快需要完成的任务，优先级【最高】
        > 添加微队列的办法主要有 Promise， MutationObserver

## Node中的EventLoop
1. Node简介
Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）

Node.js运行机制如下:
- V8引擎解析JavaScript脚本
- 解析后的代码，调用Node API。
- libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
- V8引擎再将结果返回给用户。

2. 六个阶段
其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。
node的事件循环顺序:
外部输入数据-》轮询阶段(poll)-》检查阶段(check)-》关闭时间回调阶段(close callback)-》定时器检查阶段(timer)-》I/O事件回调阶段(I/O callbacks)-》闲置阶段(idle,prepare)-》轮询阶段(按照该顺序反复运行)...
- timers阶段:这个阶段执行timer（setTimeout、setInterval）的回调
- I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
- idle, prepare 阶段：仅node内部使用
- poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
- check 阶段：执行 setImmediate() 的回调
- close callbacks 阶段：执行 socket 的 close 事件回调

注意：上面六个阶段都不包括 process.nextTick()(下文会介绍)

接下去我们详细介绍timers、poll、check这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。

1. timers  
timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在**Node 中定时器指定的时间也不是准确时间，只能是尽快执行**。
2. poll  
poll是一个至关重要的阶段，这一阶段中，系统会做两件事情
   1. 回到timer阶段执行回调
   2. 执行I/O回调
   并且在进入该阶段时如果没有设定了timer的话，会发送以下两件事情
      - 如果poll队列不为空，会遍历回调队列并同步执行，知道队列为空或达到系统限制
      - 如果poll队列为空，会有两件事情发生
        - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
        - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去

 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。  
3. check  
   setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。