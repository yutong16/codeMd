# 堆栈溢出  

## 产生原因

- 上溢:栈满时再做进栈必定产生空间溢出
- 下溢:栈空时再做退栈也产生空间溢出

最常见的就是**无限递归**或者**递归层级过深**。从而导致堆栈溢出

```javascript
// 阶乘，若用递归实现，层级不能过深
const factorial = n => n<=1?1: n*factorial(n-1)

// 斐波切纳数列也是一样
const fibonacci = n => n<=1?1 : fibonacci(n-1) + fibonacci(n-2)
```

## 解决方案  

### 递归改为循环

优化原理: 所有运算均在一个执行上下文中，不用生成额外的上下文。

### 尾调用优化

优化原理: 函数返回回溯时不需要做任何额外的计算，故可以不用保存函数的入口环境。
> 尾调用优化依赖于语言实现，其本质还是将尾调用优化为循环的实现方式。ES6之前没有对尾调用进行优化，还是会导致调用栈增长。

```javascript
const factorial = (n, result = 1) => n <= 1 ? result : factorial(n - 1, n * result)

const fibonacci = (n, prev = 1, cur = 1) => n <= 1 ? cur : fibonacci(n - 1, cur, prev + cur)`
```

# 内存泄漏

## 产生原因

由于疏忽或错误造成程序未能释放已经不再使用的内存。
例如：不再需要的闭包，定时器及全局变量等未能及时清楚引用。

## 解决方案

- 及时解除不再需要的引用，如闭包，定时器以及全局变量等；
- 使用`WeakSet, WeakMap`，它们对于值得引用是弱引用，只要外部的引用消失，内部的引用就会自动被垃圾回收清除。
