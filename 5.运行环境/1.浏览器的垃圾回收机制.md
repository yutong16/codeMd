# 垃圾回收  

`JavaScript`的内存管理是自动的，无形的。我们创建的原始值，对象，函数......这一切都会占用内存。当我们不再需要某个东西时应当回收其内存，那么`JavaScript引擎`是如何发现和清理它的呢？  

## 发现垃圾

### 可达性（Reachability）  
JavaScript中主要的内存管理概念是 **可达性**。
"可达"值是那些以某种方式可以访问或可用的值。它们一定是存储在内存中的。  

1. 这里列出固有的可达值的基本集合，这些值明显不能被释放:
   - 当前执行的函数，他的局部变量和参数
   - 当前嵌套调用链上的其他函数，它们的局部变量和参数
   - 全局变量
   - 一些内部函数，参数  
  这些值被称为 **根（Roots）**
2. 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的。比如：如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则**该**对象被认为是可达的。而且它引用的内容也是可达的。

常见案例：

- 两个引用
- 相互关联的对象
- 无法到达的岛屿
  
## 回收垃圾

垃圾回收的基本算法被称为"mark-and-sweep"。  
定期执行以下“垃圾回收”步骤:

- 垃圾收集器找到所有的根，并"标记"（记住）它们。
- 然后它遍历并“标记”来自它们的所有引用。
- 然后它遍历标记的对象并标记 **它们**的引用。所有被遍历的对象都会被记住，以免将来再次遍历到同一个对象。
- ......如此操作，知道所有可达的（从根部）引用都被访问到。
- 没有被标记的对象都会被删除。

这是垃圾收集的工作概念。JavaScript引擎做了许多优化，使得垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。
一些优化建议:

- **分代收集（Gennerational collection）**——对象被分为两组: “新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现，完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。哪些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。从而提高收集效率。
- **增量收集（Incremental collection）**—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此。引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。
- **闲时收集（Idle-time collection）**—— 垃圾收集器只在CPU空闲时尝试运行，以减少可能对代码执行的影响。


## V8的垃圾回收机制
V8是一个开源的JavaScript引擎，它被用于Chrome浏览器和Node.js等平台。V8的垃圾回收机制是V8对内存管理的实现。

V8的垃圾回收机制采用了`分代垃圾回收策略`，将内存分为`新生代`和`老生代`两个部分。**新生代内存用于存储生命周期短的对象，采用Scavenge算法进行垃圾回收**。**老生代内存用于存储生命周期长的对象，采用Mark-Sweep和Mark-Compact算法进行垃圾回收。**

在V8中，垃圾回收器会周期性地检查内存中不再使用的对象，并将其回收以释放内存空间。由于V8采用了分代垃圾回收策略，所以在回收新生代内存时，只需要扫描新生代内存中的少量存活对象即可，因此回收速度较快。而在回收老生代内存时，需要扫描的存活对象较多，因此回收速度较慢。

总的来说，V8的垃圾回收机制通过采用分代垃圾回收策略，提高了内存回收的效率，减少了内存碎片的产生，从而提高了JavaScript应用的性能和稳定性。